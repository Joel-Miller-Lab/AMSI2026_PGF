
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4.3. Distribution of Total Sizes of Extinct Disease Outbreaks &#8212; Applications of Probability Generating Functions to Biological Systems</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/InfDis/InfDisSizeDist';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4.4. SIR outbreak sizes in small populations" href="InfDisSmallPop.html" />
    <link rel="prev" title="4.2. Early Outbreak Stage and Galton-Watson Processes" href="InfDisAsGaltWat.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Applications of Probability Generating Functions to Biological Systems - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Applications of Probability Generating Functions to Biological Systems - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Probability Generating Functions and Biological Applications
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Foreword</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theorems.html">List of Theorems</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Mathematical Properties of Generating Functions</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../BasicGenFxn/GenFxns.html">1. Generating Functions</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsParadigm.html">1.2. A paradigm change</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsNotation.html">1.3. Some notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsExamples.html">1.4. Generating Function Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsProveIdent.html">1.5. Using Generating Functions to Prove Identities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsDiff.html">1.6. Differentiation of Generating Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsAdd.html">1.7. Linear Combinations of Generating Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsMult.html">1.8. Multiplication of Generating Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsComp.html">1.9. Composition of PGFs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsCoefficientCalc.html">1.10. Numerical Calculation of PGF coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsProperties.html">1.11. Properties of Generating functions</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Biological Applications of Generating Functions</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../GaltonWatson/GaltWat.html">2. The Galton-Watson Process</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatExtinct.html">2.2. Extinction of a Galton-Watson Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatDiff.html">2.3. Differentiation and the Galton Watson Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatExtinctByGen.html">2.4. Extinction probability over time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatSizeOverTime.html">2.5. Size Distribution at successive times</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../CtsTime/CtsTimeIntro.html">3. Continuous-Time Galton-Watson Processes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../CtsTime/CtsTimeGaltWat.html">3.2. Continuous Time Galton Watson Process</a></li>

<li class="toctree-l2"><a class="reference internal" href="../CtsTime/CtsTimeForwKolm.html">3.4. Forward Kolmogorov Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../CtsTime/CtsTimeBackKolm.html">3.5. The Backward Kolmogorov Equation</a></li>
</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="InfDisIntro.html">4. Infectious Diseases</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="InfDisAsGaltWat.html">4.2. Early Outbreak Stage and Galton-Watson Processes</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">4.3. Distribution of Total Sizes of Extinct Disease Outbreaks</a></li>
<li class="toctree-l2"><a class="reference internal" href="InfDisSmallPop.html">4.4. SIR outbreak sizes in small populations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Simulation/SimulationIntro.html">5. Computer Simulation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../Simulation/GaltWatSimulation.html">5.1. Simulation of a Galton-Watson Process</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../PracticeClasses/PracIntro.html">6. Practice Classes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../PracticeClasses/Prac1.html">6.1. Probability Generating Functions, Practical Class 1.</a></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/Joel-Miller-Lab/AMSI2026_PGF/main?urlpath=lab/tree/docs/notebooks/InfDis/InfDisSizeDist.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="../../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/Joel-Miller-Lab/AMSI2026_PGF" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Joel-Miller-Lab/AMSI2026_PGF/issues/new?title=Issue%20on%20page%20%2Fnotebooks/InfDis/InfDisSizeDist.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/InfDis/InfDisSizeDist.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Distribution of Total Sizes of Extinct Disease Outbreaks</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#main-theorem-and-motivations">4.3.1. Main Theorem and Motivations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setting-up-the-proof">4.3.2. Setting up the proof</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#switching-to-a-depth-first-search-of-the-nodes">4.3.3. Switching to a depth-first search of the nodes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#inverting-the-dfs-and-the-cycle-lemma">4.3.4. Inverting the DFS and the Cycle Lemma</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#completing-the-proof">4.3.5. Completing the proof</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#self-test">4.3.6. Self-test</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="distribution-of-total-sizes-of-extinct-disease-outbreaks">
<h1><span class="section-number">4.3. </span>Distribution of Total Sizes of Extinct Disease Outbreaks<a class="headerlink" href="#distribution-of-total-sizes-of-extinct-disease-outbreaks" title="Link to this heading">#</a></h1>
<section id="main-theorem-and-motivations">
<h2><span class="section-number">4.3.1. </span>Main Theorem and Motivations<a class="headerlink" href="#main-theorem-and-motivations" title="Link to this heading">#</a></h2>
<p>Often for infectious diseases we are interested in the total number of infections that occur in an outbreak.  We will prove a theorem about the probability that an SIR outbreak spreading in a very large population fails to start an epidemic and instead goes extinct with exactly <span class="math notranslate nohighlight">\(j\)</span> total infections.  The result is more general and applies to any Galton-Watson process, but infectious diseases are typically where we are most interested in knowng the total size of small outbreaks.</p>
<p>Consider a Galton-Watson Process whose offspring distribution has PGF <span class="math notranslate nohighlight">\(\mu(x)\)</span>.  It is useful to know the probability that the process goes extinct and the total size is <span class="math notranslate nohighlight">\(j =\sum_{g=0}^\infty X_g\)</span> (if it goes extinct, then for large enough <span class="math notranslate nohighlight">\(g\)</span>,  <span class="math notranslate nohighlight">\(X_g\)</span> must be zero).</p>
<p>A truly remarkable theorem lets us calculate this probability.</p>
<div class="proof theorem admonition" id="theorem-TotalSizeDist">
<p class="admonition-title"><span class="caption-number">Theorem 4.2 </span> (Distribution of Total Sizes of Galton-Watson Processes)</p>
<section class="theorem-content" id="proof-content">
<p>Given a Galton-Watson Process whose offspring distribution PGF is <span class="math notranslate nohighlight">\(\mu(x)\)</span>, the probability that the process terminates after a finite cumulative count of exactly <span class="math notranslate nohighlight">\(\sum_{g=0}^\infty X_g = j\)</span> is given by</p>
<div class="math notranslate nohighlight">
\[ \mathbb{P}\left(j=\sum X_g\right) = \frac{1}{j} p_{j-1}^{(j)}\]</div>
<p>where <span class="math notranslate nohighlight">\(p_{j-1}^{(j)}= [x^{j-1}]\left(\mu(x)^j\right)\)</span> denotes the coefficient of <span class="math notranslate nohighlight">\(x^{j-1}\)</span> in  <span class="math notranslate nohighlight">\(\mu(x)^j\)</span>.</p>
</section>
</div><div class="proof example admonition" id="example-GeomTotalSize">
<p class="admonition-title"><span class="caption-number">Example 4.1 </span> (Size distribution with a geometric offspring distribution)</p>
<section class="example-content" id="proof-content">
<p>Imagine that an individual has a probability <span class="math notranslate nohighlight">\(p\)</span> of recovering next and <span class="math notranslate nohighlight">\(1-p\)</span> of transmitting next.  Further assume that if transmission happens, then the probabilities of the next event being recovery or transmission are again <span class="math notranslate nohighlight">\(p\)</span> and <span class="math notranslate nohighlight">\(1-p\)</span>.  Finding the offspring distribution is like the weighted coin-tossing distribution we saw earlier, except that we do not count the final recovery event.  The PGF of the offspring distribution is <span class="math notranslate nohighlight">\(\mu(x)=p/(1-(1-p)x)\)</span>.  By <a class="reference internal" href="#theorem-TotalSizeDist">Theorem 4.2</a>, the probability of an outbreak of size <span class="math notranslate nohighlight">\(j\)</span> is</p>
<div class="math notranslate nohighlight">
\[
\mathbb{P}(\text{size}=j) = \frac{1}{j}p_{j-1}^{(j)}
\]</div>
<p>where <span class="math notranslate nohighlight">\(p_{j-1}^{(j)} = [x^{j-1}]\left(\mu(x)^j\right) = \left( \frac{p}{1-(1-p)x}\right)^j\)</span></p>
<p>This is the PGF for a negative binomial distribution.  The Taylor Series expansion of <span class="math notranslate nohighlight">\(\left( \frac{p}{1-(1-p)x}\right)^j\)</span> is known, and the coefficient of <span class="math notranslate nohighlight">\(x^{j-1}\)</span> is</p>
<div class="math notranslate nohighlight">
\[
p_{j-1}^{(j)} = p^j \binom{j-1+j-1}{j-1} (1-p)^{j-1} = \binom{2j-2}{j-1}p^j(1-p)^{j-1}
\]</div>
<p>Multiplying by <span class="math notranslate nohighlight">\(1/j\)</span> gives the probability of exactly <span class="math notranslate nohighlight">\(j\)</span> infections.</p>
<div class="math notranslate nohighlight">
\[
\mathbb{P}(\text{exactly $j$ infections}) = \frac{1}{j} \binom{2j-2}{j-1}p^j(1-p)^{j-1}
\]</div>
<p><strong>Do simulations and show fit</strong></p>
</section>
</div><p>When I first saw this theorem, I read a few proofs.  I didn’t really like any of them - there were a few I didn’t understand because they assumed I knew some concepts that I didn’t, or they were based in a lot of symbols and manipulations which I couldn’t re-interpret visually.  As I think very visually, I struggled to follow these.  Specifically, the <span class="math notranslate nohighlight">\(1/j\)</span> prefactor caused much confusion.  A well-known result in probability theory, the “Cycle Lemma” provides the result, but I wasn’t happy with the proofs I found.</p>
<p>I developed the proof below that (in my opinion) very elegantly explains the Cycle Lemma.  I expect that this proof is already known, it’s just not in the places that I looked.</p>
</section>
<section id="setting-up-the-proof">
<h2><span class="section-number">4.3.2. </span>Setting up the proof<a class="headerlink" href="#setting-up-the-proof" title="Link to this heading">#</a></h2>
<p>This is one of the most remarkable theorems I have seen.  I hope I can do justice to that proof below.</p>
<p>First, I’ll try to set the stage for the thought process that yielded this proof.  How might we approach proving this theorem?  Let’s start down the path to proving this result.  We’ll run into an obstacle and then backtrack a bit to modify the approach at which point the proof will be more simple.</p>
<figure class="align-default" id="fig-gwt">
<a class="reference internal image-reference" href="../../_images/GWT.png"><img alt="../../_images/GWT.png" src="../../_images/GWT.png" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.1 </span><span class="caption-text">A sample Galton-Watson tree with <span class="math notranslate nohighlight">\(j=9\)</span> nodes.  There are <span class="math notranslate nohighlight">\(8\)</span> edges.  The number of offspring, listed in order by node indices are <span class="math notranslate nohighlight">\((3,0,2,1,2,0,0,0,0)\)</span>.  The probability of observing exactly this tree is <span class="math notranslate nohighlight">\(p_3p_2^2p_1p_0^5\)</span>.</span><a class="headerlink" href="#fig-gwt" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>We will initially consider the nodes in their “natural” order: <span class="math notranslate nohighlight">\(u_{0,1}, \:u_{1,1}, \ldots, u_{1,X_1}, \: u_{2,1}, \ldots, u_{2,X_2}, \: \ldots\)</span>.  Then we create the sequence <span class="math notranslate nohighlight">\(k_{0,1}, \: k_{1,1}, \ldots, k_{1,X_1}, \: \ldots\)</span>, which we reindex as <span class="math notranslate nohighlight">\(k_1, k_2, \ldots\)</span>.</p>
<p>As we traverse the nodes of a random Galton-Watson tree, writing down the number of offspring of each node, the probability that the next node encountered has <span class="math notranslate nohighlight">\(k\)</span> offspring is <span class="math notranslate nohighlight">\(p_k\)</span>.  Thus given a <span class="math notranslate nohighlight">\(j\)</span>-node tree (with the sequence <span class="math notranslate nohighlight">\(k_1, k_2, \ldots, k_j\)</span>) we can calculate its probability to be</p>
<div class="math notranslate nohighlight">
\[
\mathbb{P}(\text{tree}) = \prod_{i=1}^j p_{k_i}
\]</div>
<p>This is equal to the probability that a random length <span class="math notranslate nohighlight">\(j\)</span> sequence of numbers chosen from the offspring distribution is <span class="math notranslate nohighlight">\(k_1, \ldots, k_j\)</span>.</p>
<p>If <span class="math notranslate nohighlight">\(k_1, k_2, \ldots, k_j\)</span> corresponds to a <span class="math notranslate nohighlight">\(j\)</span>-node Galton-Watson tree, then that correspondence is unique: the same node ordering rule will always yield the same sequence <span class="math notranslate nohighlight">\(k_1, \ldots, k_j\)</span> and given the sequence we can reconstruct the original tree.  Thus the probability that a Galton-Watson tree has <span class="math notranslate nohighlight">\(j\)</span> nodes is equal to the combined probabilities of all length-<span class="math notranslate nohighlight">\(j\)</span> sequences <span class="math notranslate nohighlight">\(k_1, \ldots, k_j\)</span> that correspond to <span class="math notranslate nohighlight">\(j\)</span>-node Galton-Watson trees.</p>
<p>To complete the proof, we “just” need to characterize all of the allowable sequences and calculate their combined probability.  To characterize them, we need to identify relevant constraints on the sequences, as not all length-<span class="math notranslate nohighlight">\(j\)</span> sequences correspond to <span class="math notranslate nohighlight">\(j\)</span>-node trees.</p>
<p>One constraint is that if the Galton-Watson tree has exactly <span class="math notranslate nohighlight">\(j\)</span> nodes, then <span class="math notranslate nohighlight">\(j-1\)</span> of them have exactly one parent and the other has no parent.  So a Galton-Watson tree having exactly <span class="math notranslate nohighlight">\(j\)</span> nodes would require that the sum of the number of offspring of all <span class="math notranslate nohighlight">\(j\)</span> nodes is <span class="math notranslate nohighlight">\(j-1\)</span>.  Thus <span class="math notranslate nohighlight">\(\sum_{i=1}^j k_i = j-1\)</span>.</p>
<p>Recall that <span class="math notranslate nohighlight">\(\mu(x)^j\)</span> is the PGF for the sum <span class="math notranslate nohighlight">\(\sum_{i=1}^j k_i\)</span>.  Thus <span class="math notranslate nohighlight">\(p_{j-1}^{(j)} =[x^{j-1}]\left(\mu(x)^j\right)\)</span> is the probability that <span class="math notranslate nohighlight">\(j\)</span> numbers would sum to <span class="math notranslate nohighlight">\(j-1\)</span>. So we can see that the probability that a tree would have exactly <span class="math notranslate nohighlight">\(j\)</span> nodes would likely be related to <span class="math notranslate nohighlight">\(p_{j-1}^{(j)}\)</span>.  However, we haven’t yet explained where the <span class="math notranslate nohighlight">\(1/j\)</span> prefactor comes from.  Indeed, we might (incorrectly, as I initially did) expect the probability a Galton-Watson tree has exactly <span class="math notranslate nohighlight">\(j\)</span> nodes should equal <span class="math notranslate nohighlight">\(p_{j-1}^{(j)}\)</span>.</p>
<p>There is still another constraint that we need to handle.  To see it, let us imagine that <span class="math notranslate nohighlight">\(j=2\)</span>.  If the first node has zero offspring and the second has one offspring, have we created a Galton-Watson tree with exactly <span class="math notranslate nohighlight">\(j=2\)</span> nodes?  No. If the first node has no offspring then the tree is already complete – there is no second node.  On the other hand if the first node has one offspring and the second has none, then we do have a Galton-Watson tree with <span class="math notranslate nohighlight">\(2\)</span> nodes. So only half of the length-<span class="math notranslate nohighlight">\(2\)</span> sequences of <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(1\)</span> that add up to <span class="math notranslate nohighlight">\(1\)</span> correspond to a valid Galton-Watson process.</p>
<p>So in addition to requiring that the number of offspring sum to <span class="math notranslate nohighlight">\(j-1\)</span>, there is a constraint on the order.  Under the formulation so far, that constraint is that no subsequence <span class="math notranslate nohighlight">\((k_1, \ldots, k_\ell)\)</span> for <span class="math notranslate nohighlight">\(\ell&lt;j\)</span> sums to <span class="math notranslate nohighlight">\(\ell-1\)</span> as this would mean that the Galton-Watson tree terminates after <span class="math notranslate nohighlight">\(\ell\)</span> nodes.</p>
</section>
<section id="switching-to-a-depth-first-search-of-the-nodes">
<h2><span class="section-number">4.3.3. </span>Switching to a depth-first search of the nodes<a class="headerlink" href="#switching-to-a-depth-first-search-of-the-nodes" title="Link to this heading">#</a></h2>
<p>However, I was never able to come up with what I considered to be a simple proof showing that no subsequence <span class="math notranslate nohighlight">\(k_1, \ldots, k_\ell\)</span> sums to <span class="math notranslate nohighlight">\(\ell-1\)</span>.  Many proofs of <a class="reference internal" href="#theorem-TotalSizeDist">Theorem 4.2</a> that I read were based on this idea, but I always struggled with it.  Instead, let’s back up a bit and construct a different proof.  Rather than using the “obvious” ordering of the nodes, we’ll use a different ordering.</p>
<p>The ordering we had above, <span class="math notranslate nohighlight">\(u_{0,1},\; u_{1,1}, \ldots, u_{1,X_1}, \; u_{2,1}, \ldots, u_{2,X_2}, \; \ldots\)</span> is called <em>breadth-first search</em> because it covers the breadth of each generation before going “deeper” (to the next generation).  Now we will switch to a <em>depth-first search</em> in which we completely explore the depth of one branch before moving on to the next.</p>
<p>We can think of this by analogy to the “line of succession” rules for European monarchies.  The king’s sons (and their sons) would have priority over the king’s brothers who in turn have priority over the king’s uncles.  Only once there are no heirs left along one branch would the next branch be considered.</p>
<div class="proof algorithm admonition" id="alg-DFS">
<p class="admonition-title"><span class="caption-number">Algorithm 4.1 </span> (Depth-first search)</p>
<section class="algorithm-content" id="proof-content">
<p>Consider a Galton-Watson Tree.  A depth-first search creates an ordering of the vertices <span class="math notranslate nohighlight">\((v_1, v_2, \ldots)\)</span> as follows:</p>
<ul class="simple">
<li><p>Set <span class="math notranslate nohighlight">\(v_1 = u_{0,1}\)</span>.</p></li>
<li><p>Proceed iteratively:</p>
<ul>
<li><p>If <span class="math notranslate nohighlight">\(v_i\)</span> has any offspring make <span class="math notranslate nohighlight">\(v_{i+1}\)</span> its first offspring.</p></li>
<li><p>If <span class="math notranslate nohighlight">\(v_i\)</span> has no offspring, find its nearest ancestor <span class="math notranslate nohighlight">\(u\)</span> with some offspring not yet in the list.  Make <span class="math notranslate nohighlight">\(v_{i+1}\)</span> be the first of <span class="math notranslate nohighlight">\(u\)</span>’s offspring that are not yet in the list.</p></li>
<li><p>If no such <span class="math notranslate nohighlight">\(u\)</span> exists, then the search is complete and all nodes have been found.</p></li>
</ul>
</li>
</ul>
</section>
</div><div class="proof definition admonition" id="def-LukWord">
<p class="admonition-title"><span class="caption-number">Definition 4.1 </span> (Łukasiewicz word.)</p>
<section class="definition-content" id="proof-content">
<p>If we find a list of nodes <span class="math notranslate nohighlight">\(v_1, \ldots, v_j\)</span> through a Depth-First search of a Galton-Watson tree, then the sequence <span class="math notranslate nohighlight">\(\mathcal{S}=k_1, \ldots, k_j\)</span> where <span class="math notranslate nohighlight">\(k_i\)</span> is the number of offspring of <span class="math notranslate nohighlight">\(v_i\)</span> is called a <strong>Łukasiewicz word</strong>.</p>
</section>
</div><div class="proof example admonition" id="ex-DFS">
<p class="admonition-title"><span class="caption-number">Example 4.2 </span> (Depth-first search)</p>
<section class="example-content" id="proof-content">
<p>A <em>depth first search</em> on the same <span class="math notranslate nohighlight">\(j=9\)</span> node Galton-Watson tree in <a class="reference internal" href="#fig-gwt"><span class="std std-numref">Fig. 4.1</span></a> is shown in <a class="reference internal" href="#fig-bfsvsdfs"><span class="std std-numref">Fig. 4.2</span></a>.  It produces the node order <span class="math notranslate nohighlight">\(u_{0,1}, u_{1,1}, u_{1,2}, u{2,1}, u_{3,1}, u_{3,2}, u_{2,2}, u_{1,3}, u_{2,3}\)</span>, which yields the Łukasiewicz word: <span class="math notranslate nohighlight">\(\mathcal{S} = (3, 0, 2, 2, 0, 0, 0, 1, 0)\)</span>.  As expected the sum of these is <span class="math notranslate nohighlight">\(8=j-1\)</span>.</p>
</section>
</div><p>A comparison of a depth-first search and a breadth-first search is illustrated in  <a class="reference internal" href="#fig-bfsvsdfs"><span class="std std-numref">Fig. 4.2</span></a>:</p>
<figure class="align-default" id="fig-bfsvsdfs">
<a class="reference internal image-reference" href="../../_images/BFSvsDFS.png"><img alt="../../_images/BFSvsDFS.png" src="../../_images/BFSvsDFS.png" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.2 </span><span class="caption-text">A breadth-first search (left) and a depth-first search (right).  The depth-first search yields a Łukasiewicz word <span class="math notranslate nohighlight">\(\mathcal{S}= (3, 0, 2, 2, 0, 0, 0, 1, 0)\)</span>.</span><a class="headerlink" href="#fig-bfsvsdfs" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="inverting-the-dfs-and-the-cycle-lemma">
<h2><span class="section-number">4.3.4. </span>Inverting the DFS and the Cycle Lemma<a class="headerlink" href="#inverting-the-dfs-and-the-cycle-lemma" title="Link to this heading">#</a></h2>
<p>As long as the offspring of each node are ordered, the Depth-First search always produces the same Łukasiewicz word and the process is invertible: given a Łukasiewicz word, we can recover the tree that produced it.</p>
<div class="proof algorithm admonition" id="alg-GWTReconstruct">
<p class="admonition-title"><span class="caption-number">Algorithm 4.2 </span> (Inverting the Depth-First search)</p>
<section class="algorithm-content" id="proof-content">
<p>We begin with a sequence <span class="math notranslate nohighlight">\(\mathcal{S} = (s_1, s_2, \ldots, s_j)\)</span> of non-negative integers of length <span class="math notranslate nohighlight">\(j\)</span>, summing to <span class="math notranslate nohighlight">\(j-1\)</span>.  We place <span class="math notranslate nohighlight">\(j\)</span> nodes around a ring.  Starting with the top node, label the nodes clockwise with the numerical values <span class="math notranslate nohighlight">\(s_1, s_2, \ldots, s_j\)</span>, representing the number of offspring that we must assign each.</p>
<p>We will iteratively process the nodes, assigning a parent to a node only once we have identified all of its children.</p>
<p>We repeat the following steps as long as there are nodes with non-zero labels:</p>
<ul class="simple">
<li><p>Consider each node <span class="math notranslate nohighlight">\(w\)</span> with a nonzero label <span class="math notranslate nohighlight">\(x_w\)</span> that is immediately followed, in the clockwise direction, by one or more nodes with a label of <span class="math notranslate nohighlight">\(0\)</span>.</p></li>
<li><p>Place an edge from <span class="math notranslate nohighlight">\(w\)</span> to the nodes immediately following it that are labelled with <span class="math notranslate nohighlight">\(0\)</span>, up to the first <span class="math notranslate nohighlight">\(x_w\)</span> of them if there are that many.</p></li>
<li><p>Remove the nodes that are now offspring of <span class="math notranslate nohighlight">\(w\)</span> from further consideration.</p></li>
<li><p>Reduce the label <span class="math notranslate nohighlight">\(x_w\)</span> by the number of edges added, so that it represents the number of offspring that still need to be assigned to <span class="math notranslate nohighlight">\(w\)</span>.</p></li>
</ul>
<p>The result is a directed tree.  <em>If</em> the original sequence <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> is a Łukasiewicz word, then the root is at the top (corresponding to the first entry of the sequence) and the resulting tree is the original tree.</p>
</section>
</div><p>We take a brief aside to define a cyclic permutation:</p>
<div class="proof definition admonition" id="definition-CyclicPerm">
<p class="admonition-title"><span class="caption-number">Definition 4.2 </span> (Cyclic Permutation)</p>
<section class="definition-content" id="proof-content">
<p>Given a sequence <span class="math notranslate nohighlight">\(\mathcal{S} = (s_1, s_2, \ldots, s_j)\)</span>, the <span class="math notranslate nohighlight">\(j\)</span> cyclic permutations of <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> are:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
&amp;(s_1, s_2, \ldots, s_j)\\
&amp;(s_2, s_3, \ldots, s_j, s_1)\\
&amp;(s_3, s_4, \ldots, s_j, s_1, s_2)\\
&amp; \vdots\\
&amp; (s_j, s_1, s_2, \ldots, s_{j-1})
\end{align*}\]</div>
</section>
</div><p>If we take a cyclic permutation of a Łukasiewicz word in <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a>, then the algorithm starts with a rotation of the same ring as for the Łukasiewicz word.  Since the algorithm steps are unaffected by rotations, the end result is a tree with the same shape as the original tree, but with the root position altered due to the rotation.  We see this in the example below:</p>
<div class="proof example admonition" id="ex-GWTReconstruct">
<p class="admonition-title"><span class="caption-number">Example 4.3 </span> (Constructing a tree from a cyclically permuted Łukasiewicz word.)</p>
<section class="example-content" id="proof-content">
<p>Consider the length-9 sequence <span class="math notranslate nohighlight">\((2, 0, 0, 0, 1, 0, 3, 0, 2)\)</span>, which is a cyclic permutation of the Łukasiewicz word <span class="math notranslate nohighlight">\((3, 0, 2, 2, 0, 0, 0, 1, 0)\)</span>.  If we follow <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a> in <code class="xref prf prf-ref docutils literal notranslate"><span class="pre">fig-ReconstructDFS</span></code>, the result is a tree.  However, the root corresponds to the position at which the Łukasiewicz word would begin.</p>
<figure class="align-default" id="fig-reconstructdfs">
<a class="reference internal image-reference" href="../../_images/ReconstructDFS.png"><img alt="../../_images/ReconstructDFS.png" src="../../_images/ReconstructDFS.png" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.3 </span><span class="caption-text">Reconstructing the rotated Galton-Watson tree from a cyclically permuted Łukasiewicz word.  The panels of the initial and final steps are highlighted.  In each panel, the ring described in <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a> is shown along with an illustration of the current status of the reconstruction. The final reconstructed tree shown at the bottom.  The final tree has the same shape as the original tree.</span><a class="headerlink" href="#fig-reconstructdfs" title="Link to this image">#</a></p>
</figcaption>
</figure>
</section>
</div><p>In the example we saw <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a> construct the original tree, with a cyclic rotation.  Was this a lucky example, or does it always happen?</p>
<p>Now we show that it is guaranteed that if a sequence of <span class="math notranslate nohighlight">\(j\)</span> non-negative integers sums to <span class="math notranslate nohighlight">\(j-1\)</span> then applying this process must generate a rooted directed tree:</p>
<ul class="simple">
<li><p>We are guaranteed at each step that the number of nodes in the ring is one more than the sum of their labels, so until only one node remains, we can find a  node with nonzero label followed by a node with label <span class="math notranslate nohighlight">\(0\)</span>.  This guarantees the process continues until only one node remains.</p></li>
<li><p>The method of adding edges guarantees that at each step, when a node has label <span class="math notranslate nohighlight">\(0\)</span>, it is either isolated, or it is the root of a directed tree made up of nodes that have been removed from the ring.  No node can get multiple parents, nor can a node’s descendent become its parent.</p></li>
</ul>
<p>Thus the end result is a directed tree whose root is the final node left in the ring.   A cyclic permutation of the sequence simply rotates the labels in the ring, which causes a corresponding cyclic permutation of the nodes in the final tree. Exactly one permutation will move the root to the top of the ring.</p>
<p>This leads us to one version of the Cycle Lemma:</p>
<div class="proof lemma admonition" id="lemma-CycleLemma">
<p class="admonition-title"><span class="caption-number">Lemma 4.1 </span> (Cycle Lemma)</p>
<section class="lemma-content" id="proof-content">
<p>Given a sequence of <span class="math notranslate nohighlight">\(j\)</span> non-negative integers summing to <span class="math notranslate nohighlight">\(j-1\)</span>, there is exactly one cyclic permutation of the sequence that is a Łukasiewicz word.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Consider a sequence <span class="math notranslate nohighlight">\(\mathcal{S} = (s_1, s_2, \ldots, s_j)\)</span> of non-negative integers that sumes to <span class="math notranslate nohighlight">\(j-1\)</span>.<br />
If we use any cyclic permutation of <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> in <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a>, we end up with the same tree because the algorithm will proceed as before on the rotated ring.</p>
<p>Exactly one of the cyclic permutations of <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> places the root at the top of the ring.  Hence exactly one cyclic permutation of <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> is a Łukasiewicz word.</p>
</div>
</section>
<section id="completing-the-proof">
<h2><span class="section-number">4.3.5. </span>Completing the proof<a class="headerlink" href="#completing-the-proof" title="Link to this heading">#</a></h2>
<p>Armed with this lemma, we are almost done.  We note:</p>
<ul class="simple">
<li><p>First: the probability a sequence of <span class="math notranslate nohighlight">\(j\)</span> numbers chosen from the offspring distribution sum to <span class="math notranslate nohighlight">\(j-1\)</span> is <span class="math notranslate nohighlight">\(p_{j-1}^{(j)}\)</span>.</p></li>
<li><p>Next: we observe that given <span class="math notranslate nohighlight">\(j\)</span> values chosen from the offspring distribution, all of its <span class="math notranslate nohighlight">\(j\)</span> cyclic permutations have the same probability.  Combined with the Cycle Lemma, we conclude that if the values sum to <span class="math notranslate nohighlight">\(j-1\)</span>, the probability that the sequence is a Łukasiewicz word is <span class="math notranslate nohighlight">\(1/j\)</span>.</p></li>
</ul>
<p>Combining these, the probability that the sequence sums to <span class="math notranslate nohighlight">\(j-1\)</span> and is a Łukasiewicz word is <span class="math notranslate nohighlight">\(\frac{1}{j} p_{j-1}^{(j)}\)</span>.  Thus we have proven:</p>
<p><em>The probability a Galton-Watson process ends with total size <span class="math notranslate nohighlight">\(\sum X_g = j\)</span> is equal to <span class="math notranslate nohighlight">\(\frac{1}{j} p_{j-1}^{(j)}\)</span> where <span class="math notranslate nohighlight">\(p_{j-1}^{(j)}=[x^{j-1}]\left(\mu(x)^j\right)\)</span>.</em></p>
</section>
<section id="self-test">
<h2><span class="section-number">4.3.6. </span>Self-test<a class="headerlink" href="#self-test" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Show the steps of <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a> using the Łukasiewicz word <span class="math notranslate nohighlight">\((3, 0, 2, 2, 0, 0, 0, 1, 0)\)</span>.</p></li>
<li><p>The proof did not fully explain why <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a> recovers the original tree.  Plausibly we could take a Łukasiewicz word from a tree, and the reconstruction method might create a tree whose Łukasiewicz word is a cyclic permutation of the original.  We will use induction to show the process works.  For this proof it is easier to work with a modified version of the algorithm in which each step adds just one edge.</p>
<ol class="arabic simple">
<li><p>Consider the Łukasiewicz word with <span class="math notranslate nohighlight">\(j=1\)</span>: <span class="math notranslate nohighlight">\(\mathcal{S}=0\)</span>.  Show that only one Galton-Watson tree corresponds to this word.</p></li>
<li><p>Now consider a Łukasiewicz word of  length <span class="math notranslate nohighlight">\(j+1\)</span> for <span class="math notranslate nohighlight">\(j \geq 1\)</span>.  Explain why if a node <span class="math notranslate nohighlight">\(v\)</span> with label zero immediately follows a node <span class="math notranslate nohighlight">\(w\)</span> with a non-zero label in the original Łukasiewicz word, then <span class="math notranslate nohighlight">\(w\)</span> must be the parent of <span class="math notranslate nohighlight">\(v\)</span>.</p></li>
<li><p>Create the <span class="math notranslate nohighlight">\(w-v\)</span> edge and remove <span class="math notranslate nohighlight">\(w\)</span> from the ring.  Now we have a smaller ring of <span class="math notranslate nohighlight">\(j\)</span> nodes.  Explain why the sequence is the Łukasiewicz word of the original tree with <span class="math notranslate nohighlight">\(v\)</span> removed.</p></li>
<li><p>Use induction to show that the remaining tree is unique and explain why the original tree must be unique.</p></li>
</ol>
</li>
<li><p>The discussion of <a class="reference internal" href="#alg-GWTReconstruct">Algorithm 4.2</a> stated that we are guaranteed that at each step the number of nodes under consideration in the ring is one more than the sum of their labels.  Explain why adding an edge in the algorithm preserves this relation.</p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "Joel-Miller-Lab/AMSI2026_PGF",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks\InfDis"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="InfDisAsGaltWat.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4.2. </span>Early Outbreak Stage and Galton-Watson Processes</p>
      </div>
    </a>
    <a class="right-next"
       href="InfDisSmallPop.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4.4. </span>SIR outbreak sizes in small populations</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#main-theorem-and-motivations">4.3.1. Main Theorem and Motivations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#setting-up-the-proof">4.3.2. Setting up the proof</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#switching-to-a-depth-first-search-of-the-nodes">4.3.3. Switching to a depth-first search of the nodes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#inverting-the-dfs-and-the-cycle-lemma">4.3.4. Inverting the DFS and the Cycle Lemma</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#completing-the-proof">4.3.5. Completing the proof</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#self-test">4.3.6. Self-test</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Joel C. Miller
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>