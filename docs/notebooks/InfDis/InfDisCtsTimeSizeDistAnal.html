
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>4.4. Total size distribution of Continuous-Time small outbreaks: \(N \to \infty\) &#8212; Applications of Probability Generating Functions to Biological Systems</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css?v=6644e6bb" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../../_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'notebooks/InfDis/InfDisCtsTimeSizeDistAnal';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="4.5. Generation-Based Infectious Disease Models" href="InfDisGenBased.html" />
    <link rel="prev" title="4.3. Statistics of small outbreaks" href="InfDisCtsTimeSizeDist_Sim.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="Applications of Probability Generating Functions to Biological Systems - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="Applications of Probability Generating Functions to Biological Systems - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Probability Generating Functions and Biological Applications
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Foreword</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Prerequisites.html">Prerequisites</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../theorems.html">List of Theorems</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Mathematical Properties of Generating Functions</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../BasicGenFxn/GenFxns.html">1. Generating Functions</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsParadigm.html">1.2. A paradigm change</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsNotation.html">1.3. Some notation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsExamples.html">1.4. Generating Function Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsProveIdent.html">1.5. Using Generating Functions to Prove Identities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsDiff.html">1.6. Differentiation of Generating Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsAdd.html">1.7. Linear Combinations of Generating Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsMult.html">1.8. Multiplication of Generating Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsComp.html">1.9. Composition of PGFs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsCoefficientCalc.html">1.10. Numerical Calculation of PGF coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../BasicGenFxn/GenFxnsProperties.html">1.11. Properties of Generating functions</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Biological Applications of Generating Functions</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../GaltonWatson/GaltWat.html">2. The Galton-Watson Process</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatExtinct.html">2.2. Extinction of a Galton-Watson Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatDiff.html">2.3. Differentiation and the Galton Watson Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatExtinctByGen.html">2.4. Extinction probability over time</a></li>
<li class="toctree-l2"><a class="reference internal" href="../GaltonWatson/GaltWatSizeOverTime.html">2.5. Size Distribution at Successive Generations</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../CtsTime/CtsTimeIntro.html">3. Continuous-Time Galton-Watson Processes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../CtsTime/CtsTimeGaltWat.html">3.2. Continuous Time Galton Watson Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../CtsTime/CtsTimeForwKolm.html">3.3. Forward Kolmogorov Equations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../CtsTime/CtsTimeBackKolm.html">3.4. The Backward Kolmogorov Equation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../CtsTime/CtsTimeSim.html">3.5. Simulating a Poisson Process</a></li>

</ul>
</details></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="InfDisIntro.html">4. Infectious Diseases</a><details open="open"><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="InfDisCtsTime.html">4.2. Infectious Diseases in Continuous Time</a></li>
<li class="toctree-l2"><a class="reference internal" href="InfDisCtsTimeSizeDist_Sim.html">4.3. Statistics of small outbreaks</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">4.4. Total size distribution of Continuous-Time small outbreaks: <span class="math notranslate nohighlight">\(N \to \infty\)</span></a></li>
<li class="toctree-l2"><a class="reference internal" href="InfDisGenBased.html">4.5. Generation-Based Infectious Disease Models</a></li>
<li class="toctree-l2"><a class="reference internal" href="InfDisSmallPop.html">4.6. SIR outbreak sizes in small populations</a></li>
</ul>
</details></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Simulations and Practice Problems</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1 has-children"><a class="reference internal" href="../Simulation/SimulationIntro.html">5. Computer Simulation</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../Simulation/GaltWatSimulation.html">5.1. Simulation of a Galton-Watson Process</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Simulation/GaltonWatsonExploration.html">5.2. Computer-based exploration of Galton-Watson Processes</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../PracticeClasses/PracIntro.html">6. Practice Classes</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../PracticeClasses/Prac1.html">6.1. Probability Generating Functions, Practical Class 1.</a></li>
<li class="toctree-l2"><a class="reference internal" href="../PracticeClasses/Prac2.html">6.2. Probability Generating Functions, Practical Class 2</a></li>
<li class="toctree-l2"><a class="reference internal" href="../PracticeClasses/Prac3.html">6.3. Probability Generating Functions, Practical Class 3</a></li>
</ul>
</details></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../Assignments/AssignmentsIntro.html">7. Assignments</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2"><a class="reference internal" href="../Assignments/Asst1.html">7.1. Assignment 1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Assignments/Asst2.html">7.2. Assignment 2</a></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-launch-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Launch interactive content">
    <i class="fas fa-rocket"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://mybinder.org/v2/gh/Joel-Miller-Lab/AMSI2026_PGF/main?urlpath=lab/tree/AMSI_2026_PGF_text/notebooks/InfDis/InfDisCtsTimeSizeDistAnal.ipynb" target="_blank"
   class="btn btn-sm dropdown-item"
   title="Launch on Binder"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  
    <img alt="Binder logo" src="../../_static/images/logo_binder.svg">
  </span>
<span class="btn__text-container">Binder</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="initThebeSBT()"
  class="btn btn-sm btn-launch-thebe dropdown-item"
  title="Launch Thebe"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-play"></i>
  </span>
<span class="btn__text-container">Live Code</span>
</button>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/Joel-Miller-Lab/AMSI2026_PGF" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Joel-Miller-Lab/AMSI2026_PGF/edit/main/AMSI_2026_PGF_text/notebooks/InfDis/InfDisCtsTimeSizeDistAnal.ipynb" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/Joel-Miller-Lab/AMSI2026_PGF/issues/new?title=Issue%20on%20page%20%2Fnotebooks/InfDis/InfDisCtsTimeSizeDistAnal.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/notebooks/InfDis/InfDisCtsTimeSizeDistAnal.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Total size distribution of Continuous-Time small outbreaks: N \to \infty</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-cycle-lemma">4.4.1. The Cycle Lemma</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-proof">4.4.1.1. First proof</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#second-proof">4.4.1.2. Second proof</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-the-probability-that-a-galton-watson-tree-has-j-nodes">4.4.2. Finding the probability that a Galton-Watson tree has <span class="math notranslate nohighlight">\(j\)</span> nodes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#self-test">4.4.3. Self-test</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="total-size-distribution-of-continuous-time-small-outbreaks-n-to-infty">
<h1><span class="section-number">4.4. </span>Total size distribution of Continuous-Time small outbreaks: <span class="math notranslate nohighlight">\(N \to \infty\)</span><a class="headerlink" href="#total-size-distribution-of-continuous-time-small-outbreaks-n-to-infty" title="Link to this heading">#</a></h1>
<p>We now study the total number infected in small outbreaks in the <span class="math notranslate nohighlight">\(N \to \infty\)</span> limit.  We do this by studying a Galton-Watson process with <span class="math notranslate nohighlight">\(r_2 = \beta\)</span> and <span class="math notranslate nohighlight">\(r_0=\gamma\)</span> having</p>
<div class="math notranslate nohighlight">
\[
\hat{\mu}(x) = \frac{\gamma}{\beta+\gamma} + \frac{\beta}{\beta+\gamma}x^2
\]</div>
<p>and starting with <span class="math notranslate nohighlight">\(X(t)=1\)</span>.</p>
<p>Although it is possible to solve the Forward Kolmogorov equations for this model analytically, the resulting solution only tells us the probability of having a given size at each given time.  The solution does not tell us about how past sizes and current sizes are correlated, and so it does not directly give us the total size distribution.</p>
<p>Instead we will use a different approach.  We first make some observations about the trees that emerge from this continuous-time Galton-Watson process.  A sample small outbreak is shown in <a class="reference internal" href="#fig-binarytreewithtime"><span class="std std-numref">Fig. 4.1</span></a>, for which each infection event corresponds to the “death” of a node and replacement by two nodes.</p>
<figure class="align-default" id="fig-binarytreewithtime">
<a class="reference internal image-reference" href="../../_images/BinaryTreeWithTime.png"><img alt="../../_images/BinaryTreeWithTime.png" src="../../_images/BinaryTreeWithTime.png" style="width: 400px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.1 </span><span class="caption-text">A sample illustration of <span class="math notranslate nohighlight">\(I(t)\)</span> for a small outbreak (which could be SIS or SIR), using a Galton-Watson conceptualization.  Each node persists for an exponentially distributed random time with rate <span class="math notranslate nohighlight">\(\beta+\gamma\)</span>.  At that point she is replaced by either <span class="math notranslate nohighlight">\(k=0\)</span> (crosses) or <span class="math notranslate nohighlight">\(k=2\)</span> nodes with identical properties. The corresponding probabilities are <span class="math notranslate nohighlight">\(p_0=\gamma/(\beta+\gamma)\)</span> and <span class="math notranslate nohighlight">\(p_2=\beta/(\beta+\gamma)\)</span>.  In the disease conceptualization, the <span class="math notranslate nohighlight">\(k=0\)</span> case corresponds to recovery.  The <span class="math notranslate nohighlight">\(k=2\)</span> case corresponds to the infected individual infecting another individual, with the same individual represented by  different nodes before and after the event (we can think of the original infected individual being the left offspring and the newly infected individual being the right offspring).  Although this plot shows <span class="math notranslate nohighlight">\(9\)</span> nodes, it corresponds to exactly <span class="math notranslate nohighlight">\(5\)</span> total individuals.</span><a class="headerlink" href="#fig-binarytreewithtime" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>We can convert this outbreak to a different representation which is simpler to analyze (but loses the time dependence):</p>
<figure class="align-default" id="fig-binarytreenotime">
<a class="reference internal image-reference" href="../../_images/BinaryTreeNoTime.png"><img alt="../../_images/BinaryTreeNoTime.png" src="../../_images/BinaryTreeNoTime.png" style="width: 400px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.2 </span><span class="caption-text">The same outbreak as in <a class="reference internal" href="#fig-binarytreewithtime"><span class="std std-numref">Fig. 4.1</span></a>, but without the time dependence.  The number of offspring of each node is more clearly visible.  Again, an individual in the disease model may be represented by multiple nodes in this Galtonrepresentation.</span><a class="headerlink" href="#fig-binarytreenotime" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>To determine the probability of a particular size, we will want to calculate the probability of a tree like in <a class="reference internal" href="#fig-binarytreenotime"><span class="std std-numref">Fig. 4.2</span></a>.  To determine this probability, we first look for properties of the tree.</p>
<p>The following properties are relatively easy to confirm:</p>
<ul class="simple">
<li><p>Each node in the Galton-Watson process has either <span class="math notranslate nohighlight">\(k=0\)</span> or <span class="math notranslate nohighlight">\(k=2\)</span> offspring.</p></li>
<li><p>Aside from the initial node, each node has a single parent.</p></li>
<li><p>The total number of nodes with <span class="math notranslate nohighlight">\(k=0\)</span> corresponds to the total number of individuals infected (each infected individual eventually recovers exactly once).</p></li>
</ul>
<p>If the total number of <em>nodes</em> in the tree is <span class="math notranslate nohighlight">\(j\)</span>, then from the fact that all nodes except the first have a single parent, we conclude that the total number of parent-offspring pairs is <span class="math notranslate nohighlight">\(j-1\)</span>.  However, this is also the sum <span class="math notranslate nohighlight">\(\sum k_i\)</span>.  So <span class="math notranslate nohighlight">\(\sum k_i = j-1\)</span>.  There are <span class="math notranslate nohighlight">\(\frac{j-1}{2}\)</span> nodes with <span class="math notranslate nohighlight">\(2\)</span> offspring, so the total number of infections is <span class="math notranslate nohighlight">\(j - \frac{j-1}{2} = \frac{j+1}{2}\)</span>.</p>
<p>We do not yet have enough information to calculate the probability of <a class="reference internal" href="#fig-binarytreenotime"><span class="std std-numref">Fig. 4.2</span></a>.  We will need an additional constraint.  To find this constraint, we first convert the tree into a sequence of <span class="math notranslate nohighlight">\(k_i\)</span>, then we will analyze the probability of that sequence.  There are two natural ways to order the nodes in <a class="reference internal" href="#fig-binarytreenotime"><span class="std std-numref">Fig. 4.2</span></a>, shown in <a class="reference internal" href="#fig-binarytreebfsvsdfs"><span class="std std-numref">Fig. 4.3</span></a>.</p>
<figure class="align-default" id="fig-binarytreebfsvsdfs">
<a class="reference internal image-reference" href="../../_images/BinaryTreeBFSvsDFS.png"><img alt="../../_images/BinaryTreeBFSvsDFS.png" src="../../_images/BinaryTreeBFSvsDFS.png" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.3 </span><span class="caption-text">The difference between Breadth-First-Search (BFS – <strong>Left</strong>) and Depth-First-Search (DFS – <strong>Right</strong>) in a tree.  In BFS we start from a node and find all nodes distance <span class="math notranslate nohighlight">\(1\)</span>, then all nodes distance <span class="math notranslate nohighlight">\(2\)</span>, etc.  Each time we encounter a node, we record its degree.  In DFS we first travel down one branch recursively, “exhausting” each branch before looking at the next branch.</span><a class="headerlink" href="#fig-binarytreebfsvsdfs" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Many people more naturally consider Breadth-First-Search (BFS).  However, for us it will be useful to use Depth-First-Search (DFS).  DFS can be considered similarly to how we might expect inheritance to travel in a Royal Family in Europe.  The king’s first son has priority, and that son’s sons come next, etc.  So long as there is at least one son along that branch of the family tree, the king’s second son is not considered.</p>
<p>The advantage for this in the proof we will be doing later is that in DFS, the offspring of a node immediately follow that node in the list.  In BFS, the location of a node’s offspring in the list depends on what happens in other parts of the tree.  It will be much easier to reconstruct a tree from its sequence of offspring counts in the DFS case than in the BFS case.</p>
<p>The sequence of offspring counts in the DFS case is called a Łukasiewicz word:</p>
<div class="proof definition admonition" id="def-LukWord">
<p class="admonition-title"><span class="caption-number">Definition 4.3 </span> (Łukasiewicz word.)</p>
<section class="definition-content" id="proof-content">
<p>If we find a list of nodes <span class="math notranslate nohighlight">\(v_1, \ldots, v_j\)</span> through a Depth-First search of a Galton-Watson tree, then the sequence <span class="math notranslate nohighlight">\(\mathcal{S}=k_1, \ldots, k_j\)</span> where <span class="math notranslate nohighlight">\(k_i\)</span> is the number of offspring of <span class="math notranslate nohighlight">\(v_i\)</span> is called a <strong>Łukasiewicz word</strong>.</p>
</section>
</div><section id="the-cycle-lemma">
<h2><span class="section-number">4.4.1. </span>The Cycle Lemma<a class="headerlink" href="#the-cycle-lemma" title="Link to this heading">#</a></h2>
<p>An important part of our proof is the Cycle Lemma.  Before giving it, we must
define a cyclic permutation:</p>
<div class="proof definition admonition" id="definition-CyclicPerm">
<p class="admonition-title"><span class="caption-number">Definition 4.4 </span> (Cyclic Permutation)</p>
<section class="definition-content" id="proof-content">
<p>Given a sequence <span class="math notranslate nohighlight">\(\mathcal{S} = (s_1, s_2, \ldots, s_j)\)</span>, the <span class="math notranslate nohighlight">\(j\)</span> cyclic permutations of <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> are:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
&amp;(s_1, s_2, \ldots, s_j)\\
&amp;(s_2, s_3, \ldots, s_j, s_1)\\
&amp;(s_3, s_4, \ldots, s_j, s_1, s_2)\\
&amp; \vdots\\
&amp; (s_j, s_1, s_2, \ldots, s_{j-1})
\end{align*}\]</div>
</section>
</div><p>Now we are ready to give the Cycle Lemma:</p>
<div class="proof lemma admonition" id="lemma-CycleLemma">
<p class="admonition-title"><span class="caption-number">Lemma 4.1 </span> (Cycle Lemma)</p>
<section class="lemma-content" id="proof-content">
<p>Given a sequence <span class="math notranslate nohighlight">\(S\)</span> of <span class="math notranslate nohighlight">\(j\)</span> non-negative integers summing to <span class="math notranslate nohighlight">\(j-1\)</span>, there is a unique tree whose Łukasiewicz word is one of the cyclic permutations of <span class="math notranslate nohighlight">\(S\)</span>.</p>
</section>
</div><div class="proof remark admonition" id="remark-3">
<p class="admonition-title"><span class="caption-number">Remark 4.2 </span></p>
<section class="remark-content" id="proof-content">
<p>Note that in the trees above, <span class="math notranslate nohighlight">\(k\)</span> was restricted to <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(2\)</span>, but the cycle lemma does not have this restriction.</p>
</section>
</div><p>The proof will proceed by induction and create the unique tree whose Łukasiewicz word is a cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span>.  I am giving two related proofs, both of which are based on algoriths that reconstruct the unique three.  The first is the way I set this up originally when I developed this proof.  I think the second approach may be more intuitive.  Both of them result in the same tree (because there is only one tree possible), but it is perhaps more obvious that the second algorithm really has no alternative outcome.</p>
<section id="first-proof">
<h3><span class="section-number">4.4.1.1. </span>First proof<a class="headerlink" href="#first-proof" title="Link to this heading">#</a></h3>
<div class="proof algorithm admonition" id="algorithm-GenerateTree">
<p class="admonition-title"><span class="caption-number">Algorithm 4.2 </span> (Constructing a tree from <span class="math notranslate nohighlight">\(S\)</span>)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input</strong></p>
<ul class="simple">
<li><p>A length-<span class="math notranslate nohighlight">\(j\)</span> sequence <span class="math notranslate nohighlight">\(S\)</span> of non-negative integers summing to <span class="math notranslate nohighlight">\(j-1\)</span></p></li>
</ul>
<p><strong>Output</strong></p>
<ul class="simple">
<li><p>The unique tree whose Łukasiewicz word is a cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span></p></li>
</ul>
<p><strong>Steps</strong></p>
<ol class="arabic">
<li><p>Place <span class="math notranslate nohighlight">\(j\)</span> nodes <span class="math notranslate nohighlight">\(u_1\)</span>, <span class="math notranslate nohighlight">\(u_2\)</span>, <span class="math notranslate nohighlight">\(\ldots\)</span>, <span class="math notranslate nohighlight">\(u_j\)</span> clockwise around a circle with <span class="math notranslate nohighlight">\(u_1\)</span> at the top.</p></li>
<li><p>Label each <span class="math notranslate nohighlight">\(u_i\)</span> with <span class="math notranslate nohighlight">\(s_i\)</span>.</p></li>
<li><p>Repeat the following steps as long as more than one node remains:</p>
<p><strong>(i)</strong> Identify a pair of adjacent nodes so that the first has  <span class="math notranslate nohighlight">\(s_m&gt;0\)</span> and the following node has label equal to <span class="math notranslate nohighlight">\(s_n=0\)</span>  There may be multiple such pairs, the choice is arbitrary.</p>
<p><strong>(ii)</strong>  Add an edge from <span class="math notranslate nohighlight">\(u_m\)</span> to <span class="math notranslate nohighlight">\(u_n\)</span>.  Remove <span class="math notranslate nohighlight">\(u_n\)</span> from the cycle, and reduce <span class="math notranslate nohighlight">\(s_m\)</span> by <span class="math notranslate nohighlight">\(1\)</span>.</p>
</li>
</ol>
</section>
</div><figure class="align-default" id="fig-cyclelemalg">
<a class="reference internal image-reference" href="../../_images/CycleLemAlg.png"><img alt="../../_images/CycleLemAlg.png" src="../../_images/CycleLemAlg.png" style="width: 100%;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.4 </span><span class="caption-text">An illustration of the steps of the algorithm.  The algorithm begins with the sequence <span class="math notranslate nohighlight">\(S=(2,2,0,0,0,1,0,3,0)\)</span>.  After adding an edge from a node (<span class="math notranslate nohighlight">\(u_8\)</span>) with positive label to a node (<span class="math notranslate nohighlight">\(u_9\)</span>) with zero label, a new shorter sequence <span class="math notranslate nohighlight">\((2,2,0,0,0,1,0,2)\)</span> emerges.  Repeated steps results in a tree, but the root of the tree is not <span class="math notranslate nohighlight">\(u_1\)</span>, but rather <span class="math notranslate nohighlight">\(u_8\)</span>.  Taking the cyclic permutation of the sequence that begins at the root of the tree results in a Łukasiewicz word.  The choice of which <span class="math notranslate nohighlight">\(u_m\)</span>, <span class="math notranslate nohighlight">\(u_n\)</span> pair to consider at any step is arbitrary as long as <span class="math notranslate nohighlight">\(u_n\)</span> immediately follows <span class="math notranslate nohighlight">\(u_m\)</span> at the current step, <span class="math notranslate nohighlight">\(s_m&gt;0\)</span>, and <span class="math notranslate nohighlight">\(s_n=0\)</span>.</span><a class="headerlink" href="#fig-cyclelemalg" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Each step of the algorithm reduces the total number of nodes in the cycle by <span class="math notranslate nohighlight">\(1\)</span> and reduces the sum of the <span class="math notranslate nohighlight">\(s_i\)</span> by <span class="math notranslate nohighlight">\(1\)</span>.  Thus the sum is always one less than the number of nodes.  This gurantees that there is always a pair of nodes for step (3.i) until only one node remains.</p>
<div class="proof admonition" id="proof">
<p>Proof. Consider a length-<span class="math notranslate nohighlight">\(j\)</span> sequence <span class="math notranslate nohighlight">\(S = (s_1, s_2, \ldots, s_j)\)</span> of non-negative integers that sum to <span class="math notranslate nohighlight">\(j-1\)</span>.</p>
<p>We will use induction on <span class="math notranslate nohighlight">\(j\)</span>.  If <span class="math notranslate nohighlight">\(j=1\)</span>, then <span class="math notranslate nohighlight">\(S=(0)\)</span>.  This is a Łukasiewicz word, and the corresponding tree is simply the isolated node <span class="math notranslate nohighlight">\(u_1\)</span> with no offspring.</p>
<p>Now consider <span class="math notranslate nohighlight">\(j \geq 2\)</span>.  Place the nodes in a cycle and label them following the first two steps of <a class="reference internal" href="#algorithm-GenerateTree">Algorithm 4.2</a>.  We will prove that there is a unique tree that can be constructed with the nodes on this cycle whose ordering corresponds to a Depth-First-Search (starting from whichever node ends up being the root).</p>
<p>The <span class="math notranslate nohighlight">\(s_i\)</span> sum to <span class="math notranslate nohighlight">\(j-1\)</span> and are all non-negative integers.  Because <span class="math notranslate nohighlight">\(0 &lt; j-1&lt; j\)</span>, we are guaranteed at least one value of <span class="math notranslate nohighlight">\(0\)</span> and one non-zero value.  It follows that somewhere there is a non-zero value <span class="math notranslate nohighlight">\(s_i&gt;0\)</span> which is followed immediately by <span class="math notranslate nohighlight">\(s_{i+1}=0\)</span>, (taking indices to be modulo <span class="math notranslate nohighlight">\(j\)</span> so that if <span class="math notranslate nohighlight">\(i=j\)</span> then <span class="math notranslate nohighlight">\(s_{j+1}=s_1\)</span>).</p>
<p>No matter what cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span> we consider, if it is a Łukasiewicz word there must be an edge from <span class="math notranslate nohighlight">\(u_i\)</span> to <span class="math notranslate nohighlight">\(u_{i+1}\)</span>.  Add an edge from <span class="math notranslate nohighlight">\(u_i\)</span> to <span class="math notranslate nohighlight">\(u_{i+1}\)</span>.</p>
<p>Consider now the new sequence <span class="math notranslate nohighlight">\(\hat{S} = (s_1, \ldots, s_{i-1}, s_i-1, s_{i+1}, \ldots, s_j)\)</span>, which has length <span class="math notranslate nohighlight">\(j-1\)</span> and sum <span class="math notranslate nohighlight">\(j-2\)</span>.  By the inductive hypothesis, there is a unique tree on the <span class="math notranslate nohighlight">\(j-1\)</span> nodes whose Łukasiewicz word is a cyclic permutation of <span class="math notranslate nohighlight">\(\hat{S}\)</span>, and this tree is constructed by <a class="reference internal" href="#algorithm-GenerateTree">Algorithm 4.2</a>.  Add the edges of this tree.  Along with the <span class="math notranslate nohighlight">\(u_i\)</span> to <span class="math notranslate nohighlight">\(u_{i+1}\)</span> edge, we have a new tree with <span class="math notranslate nohighlight">\(j-1\)</span> edges and <span class="math notranslate nohighlight">\(j\)</span> nodes.  This tree is the only possible tree constructed with this cyclic orientation.</p>
<p>We find the (unique) root of this tree <span class="math notranslate nohighlight">\(u_\ell\)</span>, and create the sequence <span class="math notranslate nohighlight">\((s_\ell, s_{\ell+1}, \ldots, s_j, s_1, \ldots, s_{\ell-1})\)</span>.  This is a cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span> and it is a Łukasiewicz word.</p>
</div>
</section>
<section id="second-proof">
<h3><span class="section-number">4.4.1.2. </span>Second proof<a class="headerlink" href="#second-proof" title="Link to this heading">#</a></h3>
<p>We provide a second algorithm to reconstruct the tree.  It lays out the nodes in the same way, but goes about the construction differently.  I think with this algorithm it is more obvious that this algorithm must produce a tree and that there is only one tree that can be created.</p>
<div class="proof algorithm admonition" id="algorithm-GenerateTreeAlt">
<p class="admonition-title"><span class="caption-number">Algorithm 4.3 </span> (Equivalent Algorithm for constructing a tree from <span class="math notranslate nohighlight">\(S\)</span>)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input</strong></p>
<ul class="simple">
<li><p>A length-<span class="math notranslate nohighlight">\(j\)</span> sequence <span class="math notranslate nohighlight">\(S\)</span> of non-negative integers summing to <span class="math notranslate nohighlight">\(j-1\)</span></p></li>
</ul>
<p><strong>Output</strong></p>
<ul class="simple">
<li><p>The unique tree whose Łukasiewicz word is a cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span></p></li>
</ul>
<p><strong>Steps</strong></p>
<ol class="arabic">
<li><p>Place <span class="math notranslate nohighlight">\(j\)</span> nodes <span class="math notranslate nohighlight">\(u_1\)</span>, <span class="math notranslate nohighlight">\(u_2\)</span>, <span class="math notranslate nohighlight">\(\ldots\)</span>, <span class="math notranslate nohighlight">\(u_j\)</span> clockwise around a circle with <span class="math notranslate nohighlight">\(u_1\)</span> at the top (as in <a class="reference internal" href="#algorithm-GenerateTree">Algorithm 4.2</a>).</p></li>
<li><p>Label each <span class="math notranslate nohighlight">\(u_i\)</span> with <span class="math notranslate nohighlight">\(s_i\)</span>.</p></li>
<li><p>Repeat the following steps as long as more than one node remains:</p>
<p><strong>(i)</strong> Choose the first node (clockwise from top) with a nonzero label <span class="math notranslate nohighlight">\(s_i\)</span>.</p>
<p><strong>(ii)</strong> Fill in the descendents of <span class="math notranslate nohighlight">\(u_i\)</span> from the nodes following it in the clockwise direction.  The sequence of <span class="math notranslate nohighlight">\(s_m\)</span> going clockwise from <span class="math notranslate nohighlight">\(u_i\)</span> must correspond to a Depth-First-Search.</p>
<p>Step (ii) will terminate once all of the descendents of <span class="math notranslate nohighlight">\(u_i\)</span> have been added to the tree.  This occurs the at the first <span class="math notranslate nohighlight">\(n\)</span> such that <span class="math notranslate nohighlight">\(n\)</span> nodes (including <span class="math notranslate nohighlight">\(u_i\)</span>) have been added for which the sum of <span class="math notranslate nohighlight">\(n\)</span> values <span class="math notranslate nohighlight">\(s_m\)</span> is <span class="math notranslate nohighlight">\(n-1\)</span>.</p>
<p><strong>(iii)</strong> Replace <span class="math notranslate nohighlight">\(s_i\)</span> with <span class="math notranslate nohighlight">\(0\)</span> (representing the fact that there are <span class="math notranslate nohighlight">\(0\)</span> additional offspring to add to it) and remove all descendents of <span class="math notranslate nohighlight">\(u_i\)</span> from the cycle.</p>
</li>
<li><p>Once step (3) is complete, all “parent”-“offspring” edges will have been created.  We put the subtrees created in each pass through (3.ii) into their appropriate positions to complete the final tree.</p></li>
</ol>
<p>(note, in hindsight, orienting everything counter-clockwise would make the ordering of offspring more consistent with a natural left to right ordering, but I don’t want to make any changes after showing this to students.)</p>
</section>
</div><p>Note that the list of nodes after replacing <span class="math notranslate nohighlight">\(s_i\)</span> with <span class="math notranslate nohighlight">\(0\)</span> and removing all descendents of <span class="math notranslate nohighlight">\(u_i\)</span> from the cycle preserves the property that the number remaining in the cycle is one more than the sum of the labels.  This guarantees that until only one node remains it is possible to find a node with a positive value.</p>
<div class="proof example admonition" id="example-GenerateTreeAlt">
<p class="admonition-title"><span class="caption-number">Example 4.1 </span> (Demonstration of <a class="reference internal" href="#algorithm-GenerateTreeAlt">Algorithm 4.3</a>)</p>
<section class="example-content" id="proof-content">
<figure class="align-right" id="fig-generatetreealt">
<a class="reference internal image-reference" href="../../_images/GenerateTreeAlt.png"><img alt="../../_images/GenerateTreeAlt.png" src="../../_images/GenerateTreeAlt.png" style="width: 300px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 4.5 </span><span class="caption-text">The steps of the Algorithm applied to <span class="math notranslate nohighlight">\(S = (1,3,0,0,0,1,1,0,2)\)</span>.</span><a class="headerlink" href="#fig-generatetreealt" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>Consider the sequence <span class="math notranslate nohighlight">\(S = (1,3, 0,0,0, 1, 1, 0, 2)\)</span>.  We put the nodes around a cycle, labelled by their offspring counts.</p>
<p>We are now ready to do the repetitive steps in (3).</p>
<ul class="simple">
<li><p>The first nonzero entry is the first node.</p></li>
<li><p>After the first pass, the entire branch descending from node <span class="math notranslate nohighlight">\(u_1\)</span> has been constructed.  The sequence of the remaining nodes is
<span class="math notranslate nohighlight">\(\hat{S} = (0, 1, 1, 0, 2)\)</span>.</p></li>
<li><p>After the second pass, the new sequence is  <span class="math notranslate nohighlight">\(\hat{\hat{S}} = (0, 2, 0)\)</span>.</p></li>
<li><p>After the thrid pass, the sequence is <span class="math notranslate nohighlight">\(\hat{\hat{\hat{S}}}=(0)\)</span>.</p></li>
</ul>
<p>The process is finished, and the remaining node is the root of the resulting tree.  In this case it is the sixth node of the original sequence.  We can construct the  Łukasiewicz word <span class="math notranslate nohighlight">\((2, 1, 3, 0, 0, 0, 1, 1, 0)\)</span>.</p>
</section>
</div><div class="proof admonition" id="proof">
<p>Proof. Short proof based on <a class="reference internal" href="#algorithm-GenerateTreeAlt">Algorithm 4.3</a></p>
<p>We show that if the sum of <span class="math notranslate nohighlight">\(S\)</span> is one less than its length, then of all of the cyclic permutations of <span class="math notranslate nohighlight">\(S\)</span>, there is exactly one that is the Łukasiewicz word of a tree, and that tree is unique.</p>
<p>We prove by induction on <span class="math notranslate nohighlight">\(j\)</span>, the length of <span class="math notranslate nohighlight">\(S\)</span>.  If we have a sequence with <span class="math notranslate nohighlight">\(j=1\)</span> and <span class="math notranslate nohighlight">\(\sum_i s_i = 0\)</span>, then <span class="math notranslate nohighlight">\(S = (0)\)</span> is the sequence and the single node is a unique tree.</p>
<p>If <span class="math notranslate nohighlight">\(j&gt;1\)</span>, then there is a positive <span class="math notranslate nohighlight">\(s_i\)</span> somewhere, and the algorithm can proceed.  On the first pass through, it finds a node <span class="math notranslate nohighlight">\(u_i\)</span> with at least one offspring.  It creates a sub-tree of nodes that descends from <span class="math notranslate nohighlight">\(u_i\)</span>.  Given the properties of depth-first-searches, the ordering of these labels after <span class="math notranslate nohighlight">\(s_i\)</span> uniquely determines the structure of that sub-tree.  That is, there is no freedom in how these nodes are joined – whether by this algorithm or by any other method – this exact subtree must end up descending from <span class="math notranslate nohighlight">\(u_i\)</span>.</p>
<p>When we remove the descendents’ labels from the cycle and reduce <span class="math notranslate nohighlight">\(s_i\)</span> to <span class="math notranslate nohighlight">\(0\)</span>, the labels in the new cycle have the property that they sum to one less than the number of labels.  So by induction<a class="footnote-reference brackets" href="#induction" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> we can assume that there is exactly one cyclic permutation of these labels that is the Łukasiewicz word of a tree, and that tree is unique.</p>
<p>We can assume the tree on these remaining labels has been constructed and then add the descendents of <span class="math notranslate nohighlight">\(u_i\)</span> under <span class="math notranslate nohighlight">\(u_i\)</span>.  The resulting tree has a Łukasiewicz word that is a cyclic permutation of the original sequence <span class="math notranslate nohighlight">\(S\)</span>.  This completes the rigorous proof.</p>
</div>
<p>In practice rather than calling to “induction” at the final step, we repeat the algorithm until it is complete.  We may construct multiple sub-trees before we finally arrive at the root and then construct the entire tree.</p>
<p>I recommend that you consider what happens if you take the original sequence in <a class="reference internal" href="#example-GenerateTreeAlt">Example 4.1</a>, and start the algorithm from the beginning, except that in step (3) you use the root node as the starting point.  You should see that every time you generate the subtree descending from any one node, there is no freedom at all.  If you don’t start at the root, you simply construct a subtree of the entire tree.</p>
</section>
</section>
<section id="finding-the-probability-that-a-galton-watson-tree-has-j-nodes">
<h2><span class="section-number">4.4.2. </span>Finding the probability that a Galton-Watson tree has <span class="math notranslate nohighlight">\(j\)</span> nodes<a class="headerlink" href="#finding-the-probability-that-a-galton-watson-tree-has-j-nodes" title="Link to this heading">#</a></h2>
<p>We consider a Galton-Watson tree as above with <span class="math notranslate nohighlight">\(p_0 = \frac{\gamma}{\beta+\gamma}\)</span> and <span class="math notranslate nohighlight">\(p_2 = \frac{\beta}{\beta+\gamma}\)</span>.  When we construct the Łukasiewicz word, at each stage the probability that the next node has <span class="math notranslate nohighlight">\(k=0\)</span> or <span class="math notranslate nohighlight">\(k=2\)</span> is an independent choice with probabilities <span class="math notranslate nohighlight">\(p_0\)</span> and <span class="math notranslate nohighlight">\(p_2\)</span>.  This means that the probability of a tree with a specific length-<span class="math notranslate nohighlight">\(j\)</span> Łukasiewicz word is equal to the probability that a length-<span class="math notranslate nohighlight">\(j\)</span> sequence of values chosen independently from the offspring distribution is that Łukasiewicz word.</p>
<p>The probability that a Galton-Watson process will terminate after exactly <span class="math notranslate nohighlight">\(j\)</span> nodes is equal to the sum of the probabilities of all such trees.  This in turn is equal to the sum of the probabilities of each Łukasiewicz word.  In other words,</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbb{P}\left[\begin{array}{c} \text{Process ends with}\\ \text{exactly $j$ nodes}\end{array}\right] 
&amp;= \sum_{\begin{array}{c}\text{trees with}\\ \text{$j$ nodes}\end{array}} \mathbb{P}[\text{tree}]\\
&amp;= \sum_{\begin{array}{c}\text{trees with}\\ \text{$j$ nodes}\end{array}} \mathbb{P}[\text{Łukasiewicz word of tree}]\\
\end{align*}\]</div>
<p>We don’t have a direct way to sum the probabilities of the Łukasiewicz words.  However, we do have a way to calculate the probability that a sequence of <span class="math notranslate nohighlight">\(j\)</span> numbers sums to <span class="math notranslate nohighlight">\(j-1\)</span> (it is <span class="math notranslate nohighlight">\([x^{j-1}]\hat{\mu}(x)^j\)</span>).  We now find a way to express the sum of the probabilities of the Łukasiewicz words in terms of this.</p>
<p>Consider a Łukasiewicz word and all of its cyclic permutations.  Call this the <strong>orbit of the Łukasiewicz word</strong>. The cycle lemma says that each length-<span class="math notranslate nohighlight">\(j\)</span> sequence that sums to <span class="math notranslate nohighlight">\(j-1\)</span> is in the orbit of exactly one Łukasiewicz word.  Or in other words, the orbits of Łukasiewicz words exactly partition the set of length-<span class="math notranslate nohighlight">\(j\)</span> sequences that sum to <span class="math notranslate nohighlight">\(j-1\)</span>. This gives hope that we can find the combined probability of the Łukasiewicz words in terms of the known probability that a length-<span class="math notranslate nohighlight">\(j\)</span> sequence sums to <span class="math notranslate nohighlight">\(j-1\)</span>.</p>
<p>Because each sequence in the orbit has the same numbers in it (just in a different order), they all have the same probability.  Thus the probability a randomly-generated sequence is in the orbit of a given Łukasiewicz word is equal to <span class="math notranslate nohighlight">\(j\)</span> times the probability of that Łukasiewicz word.  Or, equivalently, the probability of a given Łukasiewicz word is equal to <span class="math notranslate nohighlight">\(1/j\)</span> times the combined probability of all the sequences in its orbit.  We now have</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbb{P}\left[\begin{array}{c} \text{Process ends with}\\ \text{exactly $j$ nodes}\end{array}\right] 
&amp;=\sum_{\begin{array}{c} \text{trees with}\\\text{$j$ nodes}\end{array}} 
       \mathbb{P}[\text{Łukasiewicz word of tree}]\\
&amp;= \sum_{\begin{array}{c} \text{trees with}\\ \text{$j$ nodes}\end{array}} 
     \frac{1}{j} 
     \mathbb{P}\left[\begin{array}{c} \text{a random length-$j$ sequence is in}\\ \text{orbit of Łukasiewicz word of tree} \end{array}\right]
\end{align*}\]</div>
<p>We now do some Algebra and use the fact that the orbits of Łukasiewicz words form a partition of the set of length-<span class="math notranslate nohighlight">\(j\)</span> sequences that sum to <span class="math notranslate nohighlight">\(j-1\)</span>.  We first change our sums to be over the Łukasiewicz words rather than over the trees.</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbb{P}\left[\begin{array}{c} \text{Process ends with}\\ \text{exactly $j$ nodes}\end{array}\right] 
&amp;= \frac{1}{j} 
   \sum_{\begin{array}{c}\text{length $j$}\\ 
           \text{Łukasiewicz words}\end{array}} 
       \mathbb{P}\left[\begin{array}{c} \text{a random length-$j$ sequence is in} \\ 
       \text{the orbit of the Łukasiewicz word}\end{array}\right]\\
&amp;= \frac{1}{j} \mathbb{P}\left[\begin{array}{c}\text{a random length-$j$ sequence is in}\\ \text{the orbit of some Łukasiewicz word}\end{array}\right]\\
&amp;= \frac{1}{j} \mathbb{P}\left[\begin{array}{c} \text{a random length-$j$ sequence}\\ \text{sums to $j-1$} \end{array}\right]
\end{align*}\]</div>
<ul>
<li><p>To get the second line, we used the <em>law of total probability</em>.</p></li>
<li><p>To get the third line we used the fact that a length-<span class="math notranslate nohighlight">\(j\)</span> sequence sums to <span class="math notranslate nohighlight">\(j-1\)</span> iff it is in the orbit of a Łukasiewicz word which means</p>
<div class="math notranslate nohighlight">
\[\begin{split}
  \left\{
  \begin{array}{c}\text{length-$j$ sequences in the}\\ \text{orbit of some Łukasiewicz word}\end{array}
  \right\}
  =
  \left\{
  \begin{array}{c} \text{length-$j$ sequences}\\ \text{that sum to $j-1$} \end{array}
  \right\}
  \end{split}\]</div>
<p>Since the sets are the same, their probabilities are the same.</p>
</li>
</ul>
<p>Now consider the set of all length-<span class="math notranslate nohighlight">\(j\)</span> sequences that satisfy the constraint of summing to <span class="math notranslate nohighlight">\(j-1\)</span>. This has combined probability <span class="math notranslate nohighlight">\([x^{j-1}]\hat{\mu}(x)^j\)</span> by <a class="reference internal" href="../BasicGenFxn/GenFxnsMult.html#cor-PGFPower">Corollary 1.2</a> (this is the step that justifies including this result in a subject on PGFs).</p>
<p>Thus we have</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbb{P}\left[\begin{array}{c} \text{Process ends with}\\ \text{exactly $j$ nodes}\end{array}\right]  &amp;=\frac{1}{j} \mathbb{P}\left[\begin{array}{c}\text{a random length-$j$}\\ \text{sequence sums to $j-1$}\end{array}\right]\\
&amp;= \frac{1}{j} \left[x^{j-1}\right]\left(\hat{\mu}(x)^j\right)
\end{align*}\]</div>
<p>We’re now done with the major ideas of the proof.  From this point on, the ramaining steps are effectively just doing algebra to convert the probability of <span class="math notranslate nohighlight">\(j\)</span> nodes to the probability of <span class="math notranslate nohighlight">\(\ell\)</span> infections.  We have already noted that if there are <span class="math notranslate nohighlight">\(j\)</span> nodes in the tree as constructed, then the number of infections in the SIS or SIR process is <span class="math notranslate nohighlight">\(\ell = (j+1)/2\)</span>.  We first calculate the probability of <span class="math notranslate nohighlight">\(j\)</span> nodes using <span class="math notranslate nohighlight">\(\hat{\mu}(x) = \frac{\gamma}{\beta+\gamma} + \frac{\beta}{\beta+\gamma}x^2\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbb{P}\left[\begin{array}{c} \text{Process ends with}\\ \text{exactly $j$ nodes}\end{array}\right] 
&amp;= \frac{1}{j} \left[x^{j-1}\right]\big( \hat{\mu}(x)^j\big)\\
   &amp;= \frac{1}{j} \left[x^{j-1}\right] \left(\left(\frac{\gamma}{\beta+\gamma} + \frac{\beta}{\beta+\gamma} x^2 \right)^j\right)\\
   &amp;= \frac{1}{j} \left[x^{j-1}\right] \sum_{k=0}^j  \binom{j}{k} \frac{\gamma^k}{(\beta+\gamma)^k} \frac{\beta^{j-k} x^{2(j-k)}}{(\beta+\gamma)^{j-k}}\\
   &amp;= \frac{1}{j} \frac{1}{(\beta+\gamma)^j}\left[x^{j-1}\right] \sum_{k=0}^j  \binom{j}{k} \gamma^k\beta^{j-k}x^{2(j-k)}\\
   &amp;= \begin{cases} 
   \frac{1}{j} \frac{1}{(\beta+\gamma)^j} \binom{j}{\frac{j+1}{2}} \gamma^{(j+1)/2}\beta^{(j-1)/2} &amp; j \text{ odd}\\
   0 &amp; j \text{ even}
   \end{cases}
   \end{align*}\]</div>
<p>Since <span class="math notranslate nohighlight">\(\ell = (j+1)/2\)</span> is the total number of individuals infected, we conclude that the probability of <span class="math notranslate nohighlight">\(\ell\)</span> infections is</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbb{P}[\ell \text{ infections}] &amp;= \frac{1}{2\ell-1} \frac{1}{(\beta+\gamma)^{2\ell-1}} \binom{2\ell-1}{\ell} \gamma^\ell \beta^{\ell-1}\\
&amp;= \frac{\gamma^\ell \beta^{\ell-1}}{(\beta+\gamma)^{2\ell-1}} \frac{1}{2\ell-1}\frac{(2\ell-1)!}{\ell! (\ell-1)!}\\
&amp;= \frac{\gamma^\ell \beta^{\ell-1}}{(\beta+\gamma)^{2\ell-1}}\frac{1}{\ell} \frac{(2\ell-2)!}{(\ell-1)! (\ell-1)!}\\
&amp;=\frac{\gamma^\ell \beta^{\ell-1}}{(\beta+\gamma)^{2\ell-1}} \frac{1}{\ell}\binom{2\ell-2}{\ell-1}\\
&amp;= \frac{1}{\ell}\frac{\gamma^\ell \beta^{\ell-1}}{\gamma^{2\ell-1}(\beta/\gamma+1)^{2\ell-1}} \binom{2\ell-2}{\ell-1}\\
&amp;= \frac{1}{\ell}\frac{\mathcal{R}_0^{\ell-1}}{(\mathcal{R}_0+1)^{2\ell-1}} \binom{2\ell-2}{\ell-1}
\end{align*}\]</div>
<p>where we introduced the variable <span class="math notranslate nohighlight">\(\mathcal{R}_0 = \beta/\gamma\)</span>.</p>
<p>It’s natural to wonder why I converted <span class="math notranslate nohighlight">\(\frac{1}{2\ell-1} \binom{2\ell-1}{\ell}\)</span> to <span class="math notranslate nohighlight">\(\frac{1}{\ell} \binom{2\ell-2}{\ell-1}\)</span>.  I did this because I’ve looked ahead at the more general formula we will see when we look at a “generation-based” perspective and the connections are more obvious if it is written this way.</p>
<p>We have proven:</p>
<div class="proof theorem admonition" id="theorem-ctsTimeSIS_SIR_SizeDist">
<p class="admonition-title"><span class="caption-number">Theorem 4.2 </span> (Continuous-time SIS and SIR small outbreak size distribution)</p>
<section class="theorem-content" id="proof-content">
<p>Consider the SIS and SIR disease models with transmission rate <span class="math notranslate nohighlight">\(\beta\)</span> and recovery rate <span class="math notranslate nohighlight">\(\gamma\)</span> and <span class="math notranslate nohighlight">\(\mathcal{R}_0 = \beta/\gamma\)</span>.  In the <span class="math notranslate nohighlight">\(N \to \infty\)</span> limit, the probability an outbreak ends with exactly <span class="math notranslate nohighlight">\(\ell\)</span> infections is</p>
<div class="math notranslate nohighlight">
\[
\mathbb{P}[\ell \text{ infections}]=\frac{1}{\ell}\frac{\mathcal{R}_0^{\ell-1}}{(\mathcal{R}_0+1)^{2\ell-1}} \binom{2\ell-2}{\ell-1}
\]</div>
</section>
</div><div class="proof example admonition" id="example-8">
<p class="admonition-title"><span class="caption-number">Example 4.2 </span> (Small Outbreak Size Distribution if <span class="math notranslate nohighlight">\(\beta = 3\gamma/2\)</span>)</p>
<section class="example-content" id="proof-content">
<p>If <span class="math notranslate nohighlight">\(\beta = 3 \gamma/2\)</span> as in the simulations performed in earlier sections, then</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbb{P}[\ell \text{ infections}] &amp;= \frac{1}{\ell}\frac{(3/2)^{\ell-1}}{(5/2)^{2\ell-1}} \binom{2\ell-2}{\ell-1}\\
\end{align*}\]</div>
<p>This leads to</p>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Size</p></th>
<th class="head"><p>Probability</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(1\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(2/5 = 0.4\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><span class="math notranslate nohighlight">\(2\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(12/125 =0.096\)</span></p></td>
</tr>
<tr class="row-even"><td><p><span class="math notranslate nohighlight">\(3\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(3^2 2^4/5^5 = 0.04608\)</span></p></td>
</tr>
</tbody>
</table>
</div>
</section>
</div></section>
<section id="self-test">
<h2><span class="section-number">4.4.3. </span>Self-test<a class="headerlink" href="#self-test" title="Link to this heading">#</a></h2>
<ol class="arabic">
<li><p>Consider <span class="math notranslate nohighlight">\(S = (1, 0, 0, 2, 1)\)</span> use both algorithms to construct a tree and find the Łukasiewicz word.  Verify that the Łukasiewicz word is a cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Now consider the first proof and first algorithm of the Cycle Lemma.  Take <span class="math notranslate nohighlight">\(S = (1,0,0,3,0,1)\)</span>.  By looking at the <span class="math notranslate nohighlight">\((3,0)\)</span> pair and your answer to (1), perform the inductive step of the proof.  That is, consider the sequence after adding the edge for the <span class="math notranslate nohighlight">\((3,0)\)</span> pair.  Match this with your answer to (1) and then update your tree to include this edge.  Verify that the Łukasiewicz word is a cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Now consider the second proof and algorithm for the Cycle Lemma.  Take <span class="math notranslate nohighlight">\(S = (2,1,0,0,1,1,0,0,3)\)</span>.  After the first step, this should be a cyclic permuation of the sequence in (1).  Starting with your tree for (1), do the inductive step of the second proof to create the tree.    Verify that the Łukasiewicz word is a cyclic permutation of <span class="math notranslate nohighlight">\(S\)</span>.</p></li>
<li><p>Consider the offspring distribution PGF <span class="math notranslate nohighlight">\(\hat{\mu}(x)=0.25 + 0.75x^2\)</span>. We will revisit the derivation of the probability of trees of size <span class="math notranslate nohighlight">\(j\)</span> (assuming the cycle lemma is already proven).  We will consider the case <span class="math notranslate nohighlight">\(j=5\)</span>.</p>
<p><strong>(a)</strong> Write out all length-<span class="math notranslate nohighlight">\(5\)</span> sequences made up of <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2\)</span> and sum up to <span class="math notranslate nohighlight">\(4\)</span>.</p>
<p><strong>(b)</strong> Group this set of sequences into orbits of cyclic permutations.</p>
<p><strong>(c)</strong> For each orbit, find the Łukasiewicz word.</p>
<p><strong>(d)</strong> In this case each such sequence has the same probability.  Calculate this probability.</p>
<p><strong>(e)</strong> Confirm that the probability of each Łukasiewicz word is <span class="math notranslate nohighlight">\(1/5\)</span> times the probability of its orbit.</p>
<p><strong>(f)</strong> Confirm that the probability of all of the Łukasiewicz word sequences is <span class="math notranslate nohighlight">\((1/5) [x^4]\hat{\mu}(x)^5\)</span>.</p>
</li>
<li><p>Revisit (4), but this time with length-<span class="math notranslate nohighlight">\(3\)</span> sequences that sum to <span class="math notranslate nohighlight">\(2\)</span> where we have <span class="math notranslate nohighlight">\(\mu(x) = 1/4 + x/4 + 2x^2/4\)</span>.  You should see that the sequences do not all have the same probabilities.</p>
<p><strong>(a)</strong> Write out all length-<span class="math notranslate nohighlight">\(4\)</span> sequences made up of <span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, and/or <span class="math notranslate nohighlight">\(2\)</span> and sum up to <span class="math notranslate nohighlight">\(3\)</span>. (there are 16 such sequences)</p>
<p><strong>(b)</strong> Group this set of sequences into orbits of cyclic permutations.</p>
<p><strong>(c)</strong> For each orbit, find the Łukasiewicz word.</p>
<p><strong>(d)</strong> For each orbit, find the probability of the sequences.</p>
<p><strong>(e)</strong> Confirm that the probability of each Łukasiewicz word is <span class="math notranslate nohighlight">\(1/4\)</span> times the probability of all of the sequences in its orbit.</p>
<p><strong>(f)</strong> Confirm that the probability of all of the Łukasiewicz word sequences is <span class="math notranslate nohighlight">\((1/4) [x^3]\mu(x)^4\)</span>.</p>
</li>
<li><p>The proofs of the cycle lemma allow for entries that are not <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(2\)</span>.  However, for the continuous-time SIS and SIR model, we know that all entries are <span class="math notranslate nohighlight">\(0\)</span> or <span class="math notranslate nohighlight">\(2\)</span>.</p>
<p>Imagine we restricted the lemma to sequences of just <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2\)</span>.  Show that the inductive step in the first proof technique would fail, but the inductive step in the second technique would not.</p>
</li>
<li><p>Stirling’s approximation states that</p>
<div class="math notranslate nohighlight">
\[
    n! \sim \sqrt{2\pi n} \left(\frac{n}{e}\right)^n
    \]</div>
<p>(the <span class="math notranslate nohighlight">\(\sim\)</span> means that the ratio tends to <span class="math notranslate nohighlight">\(1\)</span> as <span class="math notranslate nohighlight">\(n \to \infty\)</span>)</p>
<p><strong>(a)</strong> Use this to estimate <span class="math notranslate nohighlight">\(\frac{1}{\ell}\binom{2(\ell-1)}{\ell-1}\)</span> for large <span class="math notranslate nohighlight">\(\ell\)</span>.</p>
<p><strong>(b)</strong> If <span class="math notranslate nohighlight">\(\mathcal{R}_0=1\)</span>, estimate the probability of <span class="math notranslate nohighlight">\(\ell\)</span> infections for large <span class="math notranslate nohighlight">\(\ell\)</span>.</p>
<p><strong>(c)</strong> If <span class="math notranslate nohighlight">\(\mathcal{R}_0&lt;1\)</span>, show that as <span class="math notranslate nohighlight">\(\ell\)</span> grows, the probability of <span class="math notranslate nohighlight">\(\ell\)</span> infections decays <em>much</em> faster than for <span class="math notranslate nohighlight">\(\mathcal{R}_0=1\)</span>.</p>
<p><strong>(d)</strong> Repeat (c), but for <span class="math notranslate nohighlight">\(\mathcal{R}_0&gt;1\)</span>.</p>
</li>
</ol>
<hr class="footnotes docutils" />
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="induction" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Note that you were likely first taught induction where we take <span class="math notranslate nohighlight">\(n\)</span> and then prove <span class="math notranslate nohighlight">\(n+1\)</span> in terms of <span class="math notranslate nohighlight">\(n\)</span> and then <span class="math notranslate nohighlight">\(n+2\)</span> in terms of <span class="math notranslate nohighlight">\(n+1\)</span>, etc.  In this case we have our given size <span class="math notranslate nohighlight">\(j\)</span>, and we construct something smaller than <span class="math notranslate nohighlight">\(j\)</span>.  It might be <span class="math notranslate nohighlight">\(j-1\)</span>, but it could easily be smaller (it was smaller than <span class="math notranslate nohighlight">\(j-1\)</span> in the example).  This is still fine with induction — when we are proving it for <span class="math notranslate nohighlight">\(j\)</span> we can assume it is true for <em>any</em> non-negative value smaller than <span class="math notranslate nohighlight">\(j\)</span>. This is technically called <em>strong induction</em></p>
</aside>
</aside>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "Joel-Miller-Lab/AMSI2026_PGF",
            ref: "main",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./notebooks\InfDis"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="InfDisCtsTimeSizeDist_Sim.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4.3. </span>Statistics of small outbreaks</p>
      </div>
    </a>
    <a class="right-next"
       href="InfDisGenBased.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">4.5. </span>Generation-Based Infectious Disease Models</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-cycle-lemma">4.4.1. The Cycle Lemma</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#first-proof">4.4.1.1. First proof</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#second-proof">4.4.1.2. Second proof</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#finding-the-probability-that-a-galton-watson-tree-has-j-nodes">4.4.2. Finding the probability that a Galton-Watson tree has <span class="math notranslate nohighlight">\(j\)</span> nodes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#self-test">4.4.3. Self-test</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Joel C. Miller
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>